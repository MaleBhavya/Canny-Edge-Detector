# -*- coding: utf-8 -*-
"""Bha.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xw6yhxqTWwmph3pXEqJfQFGOJgULM5j0
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
from scipy import ndimage

# Function to apply Gaussian filter for smoothing
def apply_gaussian_filter(image, sigma):
    x_range = np.arange(-3 * sigma, 3 * sigma + 1, 1)
    gaussian_kernel = calculate_gaussian(x_range, sigma)
    smoothed_x = ndimage.convolve(image.astype(float), gaussian_kernel.reshape(1, -1))
    smoothed_y = ndimage.convolve(image.astype(float), gaussian_kernel.reshape(-1, 1))
    return smoothed_x, smoothed_y

# Function to calculate Gaussian and Gaussian Derivative Kernels
def calculate_gaussian_kernels(sigma):
    x_range = np.arange(-3 * sigma, 3 * sigma + 1, 1)
    gaussian_kernel = calculate_gaussian(x_range, sigma)
    gaussian_derivative_kernel = calculate_gaussian_derivative(x_range, sigma)
    return gaussian_kernel, gaussian_derivative_kernel

# Function to calculate Gaussian function
def calculate_gaussian(x, sigma):
    denominator = 2 * np.pi * sigma ** 2
    exponent_part = - ((x * 2) / (2 * sigma * 2))
    return 1.0 / denominator * np.exp(exponent_part)

# Function to calculate the derivative of the Gaussian function
def calculate_gaussian_derivative(x, sigma):
    scaling_factor = -x / (sigma ** 3)
    exponent_part = np.exp(- (x * 2) / (2 * sigma * 2))
    normalization_factor = 1.0 / (np.sqrt(2 * np.pi) * sigma)
    return exponent_part * scaling_factor * normalization_factor

# Function to detect edges using the derivative of the Gaussian function
def detect_edges(image, gaussian_derivative_kernel):
    edge_x = ndimage.convolve(image.astype(float), gaussian_derivative_kernel.reshape(1, -1))
    edge_y = ndimage.convolve(image.astype(float), gaussian_derivative_kernel.reshape(-1, 1))
    return edge_x, edge_y

# Function to calculate gradient magnitude
def compute_gradient_magnitude(edge_x, edge_y):
    return np.sqrt(np.square(edge_x) + np.square(edge_y))

# Function to perform non-maximum suppression on the gradient magnitude
def non_maximum_suppression(gradient_magnitude, edge_x, edge_y):
    edge_direction = np.arctan2(edge_y, edge_x)
    quantized_direction = (np.round(edge_direction * (4.0 / np.pi)) + 4) % 4
    nms_result = np.zeros_like(gradient_magnitude)

    for i in range(1, gradient_magnitude.shape[0] - 1):
        for j in range(1, gradient_magnitude.shape[1] - 1):
            nms_result[i, j] = apply_nms(gradient_magnitude, quantized_direction, i, j)

    return nms_result

# Helper function for non-maximum suppression
def apply_nms(gradient_magnitude, quantized_direction, i, j):
    if quantized_direction[i, j] == 0:
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i, j - 1], gradient_magnitude[i, j + 1]) else 0
    elif quantized_direction[i, j] == 1:
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i - 1, j + 1], gradient_magnitude[i + 1, j - 1]) else 0
    elif quantized_direction[i, j] == 2:
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i - 1, j], gradient_magnitude[i + 1, j]) else 0
    else:
        return gradient_magnitude[i, j] if gradient_magnitude[i, j] >= max(gradient_magnitude[i - 1, j - 1], gradient_magnitude[i + 1, j + 1]) else 0

# Function for Hysteresis Thresholding
def hysteresis_thresholding(nms_result):
    high_threshold = np.percentile(nms_result, 90)
    low_threshold = high_threshold / 3.0

    edge_map = np.zeros_like(nms_result)
    strong_x, strong_y = np.where(nms_result >= high_threshold)
    weak_x, weak_y = np.where((nms_result <= high_threshold) & (nms_result >= low_threshold))

    edge_map[strong_x, strong_y] = 255
    edge_map[weak_x, weak_y] = 50

    return process_weak_edges(edge_map)

# Function to process weak edges by connecting them to strong edges
def process_weak_edges(edge_map):
    image_height, image_width = edge_map.shape

    for i in range(1, image_height - 1):
        for j in range(1, image_width - 1):
            if edge_map[i, j] == 50:
                if 255 in [edge_map[i + 1, j - 1], edge_map[i + 1, j], edge_map[i + 1, j + 1],
                           edge_map[i, j - 1], edge_map[i, j + 1],
                           edge_map[i - 1, j - 1], edge_map[i - 1, j], edge_map[i - 1, j + 1]]:
                    edge_map[i, j] = 255
                else:
                    edge_map[i, j] = 0
    return edge_map

# Function to plot the results
def plot_results(smoothed_x, smoothed_y, edge_x, edge_y, gradient_magnitude, nms_result, edge_map):
    plt.figure(figsize=(20, 16))

    plt.subplot(2, 3, 1)
    plt.imshow(smoothed_x, cmap="gray")
    plt.title("X Smoothed with Gaussian")

    plt.subplot(2, 3, 2)
    plt.imshow(smoothed_y, cmap="gray")
    plt.title("Y Smoothed with Gaussian")

    plt.subplot(2, 3, 3)
    plt.imshow(edge_x, cmap="gray")
    plt.title("X Edge Detection")

    plt.subplot(2, 3, 4)
    plt.imshow(edge_y, cmap="gray")
    plt.title("Y Edge Detection")

    plt.subplot(2, 3, 5)
    plt.imshow(gradient_magnitude, cmap="gray")
    plt.title("Gradient Magnitude")

    plt.subplot(2, 3, 6)
    plt.imshow(nms_result, cmap="gray")
    plt.title("Non-Maximum Suppression")

    plt.subplot(2, 4, 7)
    plt.imshow(edge_map, cmap="gray")
    plt.title("Hysteresis Thresholding")

    plt.tight_layout()
    plt.show()

# Main function to perform the edge detection workflow
def main(image, sigma):
    # Step 1: Apply Gaussian Smoothing
    smoothed_x, smoothed_y = apply_gaussian_filter(image, sigma)

    # Step 2: Calculate Gaussian derivative kernels and detect edges
    _, gaussian_derivative_kernel = calculate_gaussian_kernels(sigma)
    edge_x, edge_y = detect_edges(image, gaussian_derivative_kernel)

    # Step 3: Compute the gradient magnitude
    gradient_magnitude = compute_gradient_magnitude(edge_x, edge_y)

    # Step 4: Perform non-maximum suppression
    nms_result = non_maximum_suppression(gradient_magnitude, edge_x, edge_y)

    # Step 5: Apply hysteresis thresholding to refine the edges
    edge_map = hysteresis_thresholding(nms_result)

    # Step 6: Plot the results
    plot_results(smoothed_x, smoothed_y, edge_x, edge_y, gradient_magnitude, nms_result, edge_map)

# Load the image
input_image = cv2.imread('/content/67079.jpg', 0)

# Set sigma value for Gaussian filter
sigma_value = 0.3

# Run the main function
main(input_image, sigma_value)